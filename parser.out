Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABS
    COMMA
    COMMENT
    L_BRACKET
    QUOTE_1
    QUOTE_2
    R_BRACKET
    XOR

Grammar

Rule 0     S' -> start
Rule 1     start -> MAIN COLON body
Rule 2     body -> goto body
Rule 3     body -> unset body
Rule 4     body -> print body
Rule 5     body -> exit body
Rule 6     body -> tag body
Rule 7     body -> if body
Rule 8     body -> assign body
Rule 9     body -> declaration body
Rule 10    body -> empty
Rule 11    goto -> GOTO NAME SEMICOLON
Rule 12    unset -> UNSET L_PAR TVAR R_PAR SEMICOLON
Rule 13    unset -> UNSET L_PAR AVAR R_PAR SEMICOLON
Rule 14    unset -> UNSET L_PAR VVAR R_PAR SEMICOLON
Rule 15    unset -> UNSET L_PAR SVAR R_PAR SEMICOLON
Rule 16    unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON
Rule 17    unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON
Rule 18    print -> PRINT L_PAR TVAR R_PAR SEMICOLON
Rule 19    print -> PRINT L_PAR AVAR R_PAR SEMICOLON
Rule 20    print -> PRINT L_PAR VVAR R_PAR SEMICOLON
Rule 21    print -> PRINT L_PAR SVAR R_PAR SEMICOLON
Rule 22    print -> PRINT L_PAR SPVAR R_PAR SEMICOLON
Rule 23    print -> PRINT L_PAR RAVAR R_PAR SEMICOLON
Rule 24    exit -> EXIT SEMICOLON
Rule 25    tag -> NAME COLON
Rule 26    if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON
Rule 27    condition -> condition AND condition
Rule 28    condition -> condition OR condition
Rule 29    condition -> NOT condition
Rule 30    condition -> relational
Rule 31    relational -> arithmetic EQUAL arithmetic
Rule 32    relational -> arithmetic NOT_EQUAL arithmetic
Rule 33    relational -> arithmetic GREATER arithmetic
Rule 34    relational -> arithmetic LESS arithmetic
Rule 35    relational -> arithmetic GREATER_EQUAL arithmetic
Rule 36    relational -> arithmetic LESS_EQUAL arithmetic
Rule 37    relational -> arithmetic
Rule 38    arithmetic -> arithmetic PLUS arithmetic
Rule 39    arithmetic -> arithmetic MINUS arithmetic
Rule 40    arithmetic -> arithmetic MULTIPLY arithmetic
Rule 41    arithmetic -> arithmetic DIVIDE arithmetic
Rule 42    arithmetic -> arithmetic REMAINDER arithmetic
Rule 43    arithmetic -> INTEGER
Rule 44    arithmetic -> DECIMAL
Rule 45    arithmetic -> STRING
Rule 46    arithmetic -> var
Rule 47    var -> TVAR
Rule 48    var -> AVAR
Rule 49    var -> VVAR
Rule 50    var -> SVAR
Rule 51    var -> RAVAR
Rule 52    var -> SPVAR
Rule 53    assign -> TVAR ASSIGN condition SEMICOLON
Rule 54    assign -> AVAR ASSIGN condition SEMICOLON
Rule 55    assign -> VVAR ASSIGN condition SEMICOLON
Rule 56    assign -> SVAR ASSIGN condition SEMICOLON
Rule 57    assign -> TVAR ASSIGN conversion SEMICOLON
Rule 58    assign -> AVAR ASSIGN conversion SEMICOLON
Rule 59    assign -> VVAR ASSIGN conversion SEMICOLON
Rule 60    assign -> SVAR ASSIGN conversion SEMICOLON
Rule 61    assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
Rule 62    assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
Rule 63    assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
Rule 64    assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
Rule 65    assign -> TVAR ASSIGN bitwise SEMICOLON
Rule 66    assign -> AVAR ASSIGN bitwise SEMICOLON
Rule 67    assign -> VVAR ASSIGN bitwise SEMICOLON
Rule 68    assign -> SVAR ASSIGN bitwise SEMICOLON
Rule 69    bitwise -> var AND_B var
Rule 70    bitwise -> var OR_B var
Rule 71    bitwise -> var XOR_B var
Rule 72    bitwise -> var SHIFT_L var
Rule 73    bitwise -> var SHIFT_R var
Rule 74    bitwise -> NOT_B TVAR
Rule 75    bitwise -> NOT_B AVAR
Rule 76    bitwise -> NOT_B VVAR
Rule 77    bitwise -> NOT_B SVAR
Rule 78    conversion -> L_PAR type R_PAR var
Rule 79    type -> INT
Rule 80    type -> FLOAT
Rule 81    type -> CHAR
Rule 82    declaration -> var
Rule 83    declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 84    declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 85    declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 86    declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
Rule 87    empty -> <empty>

Terminals, with rules where they appear

ABS                  : 
AND                  : 27
AND_B                : 69
ARRAY                : 83 84 85 86
ASSIGN               : 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 83 84 85 86
AVAR                 : 13 19 48 54 58 62 66 75 84
CHAR                 : 81
COLON                : 1 25
COMMA                : 
COMMENT              : 
DECIMAL              : 44
DIVIDE               : 41
EQUAL                : 31
EXIT                 : 24
FLOAT                : 80
GOTO                 : 11 26
GREATER              : 33
GREATER_EQUAL        : 35
IF                   : 26
INT                  : 79
INTEGER              : 43
LESS                 : 34
LESS_EQUAL           : 36
L_BRACKET            : 
L_PAR                : 12 13 14 15 16 17 18 19 20 21 22 23 26 61 62 63 64 78 83 84 85 86
MAIN                 : 1
MINUS                : 39
MULTIPLY             : 40
NAME                 : 11 25 26
NOT                  : 29
NOT_B                : 74 75 76 77
NOT_EQUAL            : 32
OR                   : 28
OR_B                 : 70
PLUS                 : 38
PRINT                : 18 19 20 21 22 23
QUOTE_1              : 
QUOTE_2              : 
RAVAR                : 17 23 51
READ                 : 61 62 63 64
REMAINDER            : 42
R_BRACKET            : 
R_PAR                : 12 13 14 15 16 17 18 19 20 21 22 23 26 61 62 63 64 78 83 84 85 86
SEMICOLON            : 11 12 13 14 15 16 17 18 19 20 21 22 23 24 26 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 83 84 85 86
SHIFT_L              : 72
SHIFT_R              : 73
SPVAR                : 16 22 52
STRING               : 45
SVAR                 : 15 21 50 56 60 64 68 77 86
TVAR                 : 12 18 47 53 57 61 65 74 83
UNSET                : 12 13 14 15 16 17
VVAR                 : 14 20 49 55 59 63 67 76 85
XOR                  : 
XOR_B                : 71
error                : 

Nonterminals, with rules where they appear

arithmetic           : 31 31 32 32 33 33 34 34 35 35 36 36 37 38 38 39 39 40 40 41 41 42 42
assign               : 8
bitwise              : 65 66 67 68
body                 : 1 2 3 4 5 6 7 8 9
condition            : 26 27 27 28 28 29 53 54 55 56
conversion           : 57 58 59 60
declaration          : 9
empty                : 10
exit                 : 5
goto                 : 2
if                   : 7
print                : 4
relational           : 30
start                : 0
tag                  : 6
type                 : 78
unset                : 3
var                  : 46 69 69 70 70 71 71 72 72 73 73 78 82

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . MAIN COLON body

    MAIN            shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> MAIN . COLON body

    COLON           shift and go to state 3


state 3

    (1) start -> MAIN COLON . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    body                           shift and go to state 4
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 4

    (1) start -> MAIN COLON body .

    $end            reduce using rule 1 (start -> MAIN COLON body .)


state 5

    (2) body -> goto . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    goto                           shift and go to state 5
    body                           shift and go to state 27
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 6

    (3) body -> unset . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    unset                          shift and go to state 6
    body                           shift and go to state 28
    goto                           shift and go to state 5
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 7

    (4) body -> print . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    print                          shift and go to state 7
    body                           shift and go to state 29
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 8

    (5) body -> exit . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    exit                           shift and go to state 8
    body                           shift and go to state 30
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 9

    (6) body -> tag . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    tag                            shift and go to state 9
    body                           shift and go to state 31
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    if                             shift and go to state 10
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 10

    (7) body -> if . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    if                             shift and go to state 10
    body                           shift and go to state 32
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    assign                         shift and go to state 11
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 11

    (8) body -> assign . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    assign                         shift and go to state 11
    body                           shift and go to state 33
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    declaration                    shift and go to state 12
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 12

    (9) body -> declaration . body
    (2) body -> . goto body
    (3) body -> . unset body
    (4) body -> . print body
    (5) body -> . exit body
    (6) body -> . tag body
    (7) body -> . if body
    (8) body -> . assign body
    (9) body -> . declaration body
    (10) body -> . empty
    (11) goto -> . GOTO NAME SEMICOLON
    (12) unset -> . UNSET L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> . UNSET L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> . UNSET L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> . UNSET L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> . UNSET L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> . UNSET L_PAR RAVAR R_PAR SEMICOLON
    (18) print -> . PRINT L_PAR TVAR R_PAR SEMICOLON
    (19) print -> . PRINT L_PAR AVAR R_PAR SEMICOLON
    (20) print -> . PRINT L_PAR VVAR R_PAR SEMICOLON
    (21) print -> . PRINT L_PAR SVAR R_PAR SEMICOLON
    (22) print -> . PRINT L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> . PRINT L_PAR RAVAR R_PAR SEMICOLON
    (24) exit -> . EXIT SEMICOLON
    (25) tag -> . NAME COLON
    (26) if -> . IF L_PAR condition R_PAR GOTO NAME SEMICOLON
    (53) assign -> . TVAR ASSIGN condition SEMICOLON
    (54) assign -> . AVAR ASSIGN condition SEMICOLON
    (55) assign -> . VVAR ASSIGN condition SEMICOLON
    (56) assign -> . SVAR ASSIGN condition SEMICOLON
    (57) assign -> . TVAR ASSIGN conversion SEMICOLON
    (58) assign -> . AVAR ASSIGN conversion SEMICOLON
    (59) assign -> . VVAR ASSIGN conversion SEMICOLON
    (60) assign -> . SVAR ASSIGN conversion SEMICOLON
    (61) assign -> . TVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (62) assign -> . AVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (63) assign -> . VVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (64) assign -> . SVAR ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> . TVAR ASSIGN bitwise SEMICOLON
    (66) assign -> . AVAR ASSIGN bitwise SEMICOLON
    (67) assign -> . VVAR ASSIGN bitwise SEMICOLON
    (68) assign -> . SVAR ASSIGN bitwise SEMICOLON
    (82) declaration -> . var
    (83) declaration -> . TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (84) declaration -> . AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (85) declaration -> . VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (86) declaration -> . SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (87) empty -> .
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    GOTO            shift and go to state 14
    UNSET           shift and go to state 16
    PRINT           shift and go to state 23
    EXIT            shift and go to state 24
    NAME            shift and go to state 15
    IF              shift and go to state 25
    TVAR            shift and go to state 17
    AVAR            shift and go to state 18
    VVAR            shift and go to state 19
    SVAR            shift and go to state 20
    $end            reduce using rule 87 (empty -> .)
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    declaration                    shift and go to state 12
    body                           shift and go to state 34
    goto                           shift and go to state 5
    unset                          shift and go to state 6
    print                          shift and go to state 7
    exit                           shift and go to state 8
    tag                            shift and go to state 9
    if                             shift and go to state 10
    assign                         shift and go to state 11
    empty                          shift and go to state 13
    var                            shift and go to state 26

state 13

    (10) body -> empty .

    $end            reduce using rule 10 (body -> empty .)


state 14

    (11) goto -> GOTO . NAME SEMICOLON

    NAME            shift and go to state 35


state 15

    (25) tag -> NAME . COLON

    COLON           shift and go to state 36


state 16

    (12) unset -> UNSET . L_PAR TVAR R_PAR SEMICOLON
    (13) unset -> UNSET . L_PAR AVAR R_PAR SEMICOLON
    (14) unset -> UNSET . L_PAR VVAR R_PAR SEMICOLON
    (15) unset -> UNSET . L_PAR SVAR R_PAR SEMICOLON
    (16) unset -> UNSET . L_PAR SPVAR R_PAR SEMICOLON
    (17) unset -> UNSET . L_PAR RAVAR R_PAR SEMICOLON

    L_PAR           shift and go to state 37


state 17

    (53) assign -> TVAR . ASSIGN condition SEMICOLON
    (57) assign -> TVAR . ASSIGN conversion SEMICOLON
    (61) assign -> TVAR . ASSIGN READ L_PAR R_PAR SEMICOLON
    (65) assign -> TVAR . ASSIGN bitwise SEMICOLON
    (83) declaration -> TVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (47) var -> TVAR .

    ASSIGN          shift and go to state 38
    GOTO            reduce using rule 47 (var -> TVAR .)
    UNSET           reduce using rule 47 (var -> TVAR .)
    PRINT           reduce using rule 47 (var -> TVAR .)
    EXIT            reduce using rule 47 (var -> TVAR .)
    NAME            reduce using rule 47 (var -> TVAR .)
    IF              reduce using rule 47 (var -> TVAR .)
    TVAR            reduce using rule 47 (var -> TVAR .)
    AVAR            reduce using rule 47 (var -> TVAR .)
    VVAR            reduce using rule 47 (var -> TVAR .)
    SVAR            reduce using rule 47 (var -> TVAR .)
    RAVAR           reduce using rule 47 (var -> TVAR .)
    SPVAR           reduce using rule 47 (var -> TVAR .)
    $end            reduce using rule 47 (var -> TVAR .)


state 18

    (54) assign -> AVAR . ASSIGN condition SEMICOLON
    (58) assign -> AVAR . ASSIGN conversion SEMICOLON
    (62) assign -> AVAR . ASSIGN READ L_PAR R_PAR SEMICOLON
    (66) assign -> AVAR . ASSIGN bitwise SEMICOLON
    (84) declaration -> AVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (48) var -> AVAR .

    ASSIGN          shift and go to state 39
    GOTO            reduce using rule 48 (var -> AVAR .)
    UNSET           reduce using rule 48 (var -> AVAR .)
    PRINT           reduce using rule 48 (var -> AVAR .)
    EXIT            reduce using rule 48 (var -> AVAR .)
    NAME            reduce using rule 48 (var -> AVAR .)
    IF              reduce using rule 48 (var -> AVAR .)
    TVAR            reduce using rule 48 (var -> AVAR .)
    AVAR            reduce using rule 48 (var -> AVAR .)
    VVAR            reduce using rule 48 (var -> AVAR .)
    SVAR            reduce using rule 48 (var -> AVAR .)
    RAVAR           reduce using rule 48 (var -> AVAR .)
    SPVAR           reduce using rule 48 (var -> AVAR .)
    $end            reduce using rule 48 (var -> AVAR .)


state 19

    (55) assign -> VVAR . ASSIGN condition SEMICOLON
    (59) assign -> VVAR . ASSIGN conversion SEMICOLON
    (63) assign -> VVAR . ASSIGN READ L_PAR R_PAR SEMICOLON
    (67) assign -> VVAR . ASSIGN bitwise SEMICOLON
    (85) declaration -> VVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (49) var -> VVAR .

    ASSIGN          shift and go to state 40
    GOTO            reduce using rule 49 (var -> VVAR .)
    UNSET           reduce using rule 49 (var -> VVAR .)
    PRINT           reduce using rule 49 (var -> VVAR .)
    EXIT            reduce using rule 49 (var -> VVAR .)
    NAME            reduce using rule 49 (var -> VVAR .)
    IF              reduce using rule 49 (var -> VVAR .)
    TVAR            reduce using rule 49 (var -> VVAR .)
    AVAR            reduce using rule 49 (var -> VVAR .)
    VVAR            reduce using rule 49 (var -> VVAR .)
    SVAR            reduce using rule 49 (var -> VVAR .)
    RAVAR           reduce using rule 49 (var -> VVAR .)
    SPVAR           reduce using rule 49 (var -> VVAR .)
    $end            reduce using rule 49 (var -> VVAR .)


state 20

    (56) assign -> SVAR . ASSIGN condition SEMICOLON
    (60) assign -> SVAR . ASSIGN conversion SEMICOLON
    (64) assign -> SVAR . ASSIGN READ L_PAR R_PAR SEMICOLON
    (68) assign -> SVAR . ASSIGN bitwise SEMICOLON
    (86) declaration -> SVAR . ASSIGN ARRAY L_PAR R_PAR SEMICOLON
    (50) var -> SVAR .

    ASSIGN          shift and go to state 41
    GOTO            reduce using rule 50 (var -> SVAR .)
    UNSET           reduce using rule 50 (var -> SVAR .)
    PRINT           reduce using rule 50 (var -> SVAR .)
    EXIT            reduce using rule 50 (var -> SVAR .)
    NAME            reduce using rule 50 (var -> SVAR .)
    IF              reduce using rule 50 (var -> SVAR .)
    TVAR            reduce using rule 50 (var -> SVAR .)
    AVAR            reduce using rule 50 (var -> SVAR .)
    VVAR            reduce using rule 50 (var -> SVAR .)
    SVAR            reduce using rule 50 (var -> SVAR .)
    RAVAR           reduce using rule 50 (var -> SVAR .)
    SPVAR           reduce using rule 50 (var -> SVAR .)
    $end            reduce using rule 50 (var -> SVAR .)


state 21

    (52) var -> SPVAR .

    GOTO            reduce using rule 52 (var -> SPVAR .)
    UNSET           reduce using rule 52 (var -> SPVAR .)
    PRINT           reduce using rule 52 (var -> SPVAR .)
    EXIT            reduce using rule 52 (var -> SPVAR .)
    NAME            reduce using rule 52 (var -> SPVAR .)
    IF              reduce using rule 52 (var -> SPVAR .)
    TVAR            reduce using rule 52 (var -> SPVAR .)
    AVAR            reduce using rule 52 (var -> SPVAR .)
    VVAR            reduce using rule 52 (var -> SPVAR .)
    SVAR            reduce using rule 52 (var -> SPVAR .)
    RAVAR           reduce using rule 52 (var -> SPVAR .)
    SPVAR           reduce using rule 52 (var -> SPVAR .)
    $end            reduce using rule 52 (var -> SPVAR .)
    AND_B           reduce using rule 52 (var -> SPVAR .)
    OR_B            reduce using rule 52 (var -> SPVAR .)
    XOR_B           reduce using rule 52 (var -> SPVAR .)
    SHIFT_L         reduce using rule 52 (var -> SPVAR .)
    SHIFT_R         reduce using rule 52 (var -> SPVAR .)
    EQUAL           reduce using rule 52 (var -> SPVAR .)
    NOT_EQUAL       reduce using rule 52 (var -> SPVAR .)
    GREATER         reduce using rule 52 (var -> SPVAR .)
    LESS            reduce using rule 52 (var -> SPVAR .)
    GREATER_EQUAL   reduce using rule 52 (var -> SPVAR .)
    LESS_EQUAL      reduce using rule 52 (var -> SPVAR .)
    PLUS            reduce using rule 52 (var -> SPVAR .)
    MINUS           reduce using rule 52 (var -> SPVAR .)
    MULTIPLY        reduce using rule 52 (var -> SPVAR .)
    DIVIDE          reduce using rule 52 (var -> SPVAR .)
    REMAINDER       reduce using rule 52 (var -> SPVAR .)
    SEMICOLON       reduce using rule 52 (var -> SPVAR .)
    AND             reduce using rule 52 (var -> SPVAR .)
    OR              reduce using rule 52 (var -> SPVAR .)
    R_PAR           reduce using rule 52 (var -> SPVAR .)


state 22

    (51) var -> RAVAR .

    GOTO            reduce using rule 51 (var -> RAVAR .)
    UNSET           reduce using rule 51 (var -> RAVAR .)
    PRINT           reduce using rule 51 (var -> RAVAR .)
    EXIT            reduce using rule 51 (var -> RAVAR .)
    NAME            reduce using rule 51 (var -> RAVAR .)
    IF              reduce using rule 51 (var -> RAVAR .)
    TVAR            reduce using rule 51 (var -> RAVAR .)
    AVAR            reduce using rule 51 (var -> RAVAR .)
    VVAR            reduce using rule 51 (var -> RAVAR .)
    SVAR            reduce using rule 51 (var -> RAVAR .)
    RAVAR           reduce using rule 51 (var -> RAVAR .)
    SPVAR           reduce using rule 51 (var -> RAVAR .)
    $end            reduce using rule 51 (var -> RAVAR .)
    AND_B           reduce using rule 51 (var -> RAVAR .)
    OR_B            reduce using rule 51 (var -> RAVAR .)
    XOR_B           reduce using rule 51 (var -> RAVAR .)
    SHIFT_L         reduce using rule 51 (var -> RAVAR .)
    SHIFT_R         reduce using rule 51 (var -> RAVAR .)
    EQUAL           reduce using rule 51 (var -> RAVAR .)
    NOT_EQUAL       reduce using rule 51 (var -> RAVAR .)
    GREATER         reduce using rule 51 (var -> RAVAR .)
    LESS            reduce using rule 51 (var -> RAVAR .)
    GREATER_EQUAL   reduce using rule 51 (var -> RAVAR .)
    LESS_EQUAL      reduce using rule 51 (var -> RAVAR .)
    PLUS            reduce using rule 51 (var -> RAVAR .)
    MINUS           reduce using rule 51 (var -> RAVAR .)
    MULTIPLY        reduce using rule 51 (var -> RAVAR .)
    DIVIDE          reduce using rule 51 (var -> RAVAR .)
    REMAINDER       reduce using rule 51 (var -> RAVAR .)
    SEMICOLON       reduce using rule 51 (var -> RAVAR .)
    AND             reduce using rule 51 (var -> RAVAR .)
    OR              reduce using rule 51 (var -> RAVAR .)
    R_PAR           reduce using rule 51 (var -> RAVAR .)


state 23

    (18) print -> PRINT . L_PAR TVAR R_PAR SEMICOLON
    (19) print -> PRINT . L_PAR AVAR R_PAR SEMICOLON
    (20) print -> PRINT . L_PAR VVAR R_PAR SEMICOLON
    (21) print -> PRINT . L_PAR SVAR R_PAR SEMICOLON
    (22) print -> PRINT . L_PAR SPVAR R_PAR SEMICOLON
    (23) print -> PRINT . L_PAR RAVAR R_PAR SEMICOLON

    L_PAR           shift and go to state 42


state 24

    (24) exit -> EXIT . SEMICOLON

    SEMICOLON       shift and go to state 43


state 25

    (26) if -> IF . L_PAR condition R_PAR GOTO NAME SEMICOLON

    L_PAR           shift and go to state 44


state 26

    (82) declaration -> var .

    GOTO            reduce using rule 82 (declaration -> var .)
    UNSET           reduce using rule 82 (declaration -> var .)
    PRINT           reduce using rule 82 (declaration -> var .)
    EXIT            reduce using rule 82 (declaration -> var .)
    NAME            reduce using rule 82 (declaration -> var .)
    IF              reduce using rule 82 (declaration -> var .)
    TVAR            reduce using rule 82 (declaration -> var .)
    AVAR            reduce using rule 82 (declaration -> var .)
    VVAR            reduce using rule 82 (declaration -> var .)
    SVAR            reduce using rule 82 (declaration -> var .)
    RAVAR           reduce using rule 82 (declaration -> var .)
    SPVAR           reduce using rule 82 (declaration -> var .)
    $end            reduce using rule 82 (declaration -> var .)


state 27

    (2) body -> goto body .

    $end            reduce using rule 2 (body -> goto body .)


state 28

    (3) body -> unset body .

    $end            reduce using rule 3 (body -> unset body .)


state 29

    (4) body -> print body .

    $end            reduce using rule 4 (body -> print body .)


state 30

    (5) body -> exit body .

    $end            reduce using rule 5 (body -> exit body .)


state 31

    (6) body -> tag body .

    $end            reduce using rule 6 (body -> tag body .)


state 32

    (7) body -> if body .

    $end            reduce using rule 7 (body -> if body .)


state 33

    (8) body -> assign body .

    $end            reduce using rule 8 (body -> assign body .)


state 34

    (9) body -> declaration body .

    $end            reduce using rule 9 (body -> declaration body .)


state 35

    (11) goto -> GOTO NAME . SEMICOLON

    SEMICOLON       shift and go to state 45


state 36

    (25) tag -> NAME COLON .

    GOTO            reduce using rule 25 (tag -> NAME COLON .)
    UNSET           reduce using rule 25 (tag -> NAME COLON .)
    PRINT           reduce using rule 25 (tag -> NAME COLON .)
    EXIT            reduce using rule 25 (tag -> NAME COLON .)
    NAME            reduce using rule 25 (tag -> NAME COLON .)
    IF              reduce using rule 25 (tag -> NAME COLON .)
    TVAR            reduce using rule 25 (tag -> NAME COLON .)
    AVAR            reduce using rule 25 (tag -> NAME COLON .)
    VVAR            reduce using rule 25 (tag -> NAME COLON .)
    SVAR            reduce using rule 25 (tag -> NAME COLON .)
    RAVAR           reduce using rule 25 (tag -> NAME COLON .)
    SPVAR           reduce using rule 25 (tag -> NAME COLON .)
    $end            reduce using rule 25 (tag -> NAME COLON .)


state 37

    (12) unset -> UNSET L_PAR . TVAR R_PAR SEMICOLON
    (13) unset -> UNSET L_PAR . AVAR R_PAR SEMICOLON
    (14) unset -> UNSET L_PAR . VVAR R_PAR SEMICOLON
    (15) unset -> UNSET L_PAR . SVAR R_PAR SEMICOLON
    (16) unset -> UNSET L_PAR . SPVAR R_PAR SEMICOLON
    (17) unset -> UNSET L_PAR . RAVAR R_PAR SEMICOLON

    TVAR            shift and go to state 46
    AVAR            shift and go to state 47
    VVAR            shift and go to state 48
    SVAR            shift and go to state 49
    SPVAR           shift and go to state 50
    RAVAR           shift and go to state 51


state 38

    (53) assign -> TVAR ASSIGN . condition SEMICOLON
    (57) assign -> TVAR ASSIGN . conversion SEMICOLON
    (61) assign -> TVAR ASSIGN . READ L_PAR R_PAR SEMICOLON
    (65) assign -> TVAR ASSIGN . bitwise SEMICOLON
    (83) declaration -> TVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON
    (27) condition -> . condition AND condition
    (28) condition -> . condition OR condition
    (29) condition -> . NOT condition
    (30) condition -> . relational
    (78) conversion -> . L_PAR type R_PAR var
    (69) bitwise -> . var AND_B var
    (70) bitwise -> . var OR_B var
    (71) bitwise -> . var XOR_B var
    (72) bitwise -> . var SHIFT_L var
    (73) bitwise -> . var SHIFT_R var
    (74) bitwise -> . NOT_B TVAR
    (75) bitwise -> . NOT_B AVAR
    (76) bitwise -> . NOT_B VVAR
    (77) bitwise -> . NOT_B SVAR
    (31) relational -> . arithmetic EQUAL arithmetic
    (32) relational -> . arithmetic NOT_EQUAL arithmetic
    (33) relational -> . arithmetic GREATER arithmetic
    (34) relational -> . arithmetic LESS arithmetic
    (35) relational -> . arithmetic GREATER_EQUAL arithmetic
    (36) relational -> . arithmetic LESS_EQUAL arithmetic
    (37) relational -> . arithmetic
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var

    READ            shift and go to state 55
    ARRAY           shift and go to state 58
    NOT             shift and go to state 59
    L_PAR           shift and go to state 56
    NOT_B           shift and go to state 62
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21
    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69

    condition                      shift and go to state 53
    conversion                     shift and go to state 54
    bitwise                        shift and go to state 57
    relational                     shift and go to state 60
    var                            shift and go to state 61
    arithmetic                     shift and go to state 66

state 39

    (54) assign -> AVAR ASSIGN . condition SEMICOLON
    (58) assign -> AVAR ASSIGN . conversion SEMICOLON
    (62) assign -> AVAR ASSIGN . READ L_PAR R_PAR SEMICOLON
    (66) assign -> AVAR ASSIGN . bitwise SEMICOLON
    (84) declaration -> AVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON
    (27) condition -> . condition AND condition
    (28) condition -> . condition OR condition
    (29) condition -> . NOT condition
    (30) condition -> . relational
    (78) conversion -> . L_PAR type R_PAR var
    (69) bitwise -> . var AND_B var
    (70) bitwise -> . var OR_B var
    (71) bitwise -> . var XOR_B var
    (72) bitwise -> . var SHIFT_L var
    (73) bitwise -> . var SHIFT_R var
    (74) bitwise -> . NOT_B TVAR
    (75) bitwise -> . NOT_B AVAR
    (76) bitwise -> . NOT_B VVAR
    (77) bitwise -> . NOT_B SVAR
    (31) relational -> . arithmetic EQUAL arithmetic
    (32) relational -> . arithmetic NOT_EQUAL arithmetic
    (33) relational -> . arithmetic GREATER arithmetic
    (34) relational -> . arithmetic LESS arithmetic
    (35) relational -> . arithmetic GREATER_EQUAL arithmetic
    (36) relational -> . arithmetic LESS_EQUAL arithmetic
    (37) relational -> . arithmetic
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var

    READ            shift and go to state 72
    ARRAY           shift and go to state 74
    NOT             shift and go to state 59
    L_PAR           shift and go to state 56
    NOT_B           shift and go to state 62
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21
    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69

    condition                      shift and go to state 70
    conversion                     shift and go to state 71
    bitwise                        shift and go to state 73
    relational                     shift and go to state 60
    var                            shift and go to state 61
    arithmetic                     shift and go to state 66

state 40

    (55) assign -> VVAR ASSIGN . condition SEMICOLON
    (59) assign -> VVAR ASSIGN . conversion SEMICOLON
    (63) assign -> VVAR ASSIGN . READ L_PAR R_PAR SEMICOLON
    (67) assign -> VVAR ASSIGN . bitwise SEMICOLON
    (85) declaration -> VVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON
    (27) condition -> . condition AND condition
    (28) condition -> . condition OR condition
    (29) condition -> . NOT condition
    (30) condition -> . relational
    (78) conversion -> . L_PAR type R_PAR var
    (69) bitwise -> . var AND_B var
    (70) bitwise -> . var OR_B var
    (71) bitwise -> . var XOR_B var
    (72) bitwise -> . var SHIFT_L var
    (73) bitwise -> . var SHIFT_R var
    (74) bitwise -> . NOT_B TVAR
    (75) bitwise -> . NOT_B AVAR
    (76) bitwise -> . NOT_B VVAR
    (77) bitwise -> . NOT_B SVAR
    (31) relational -> . arithmetic EQUAL arithmetic
    (32) relational -> . arithmetic NOT_EQUAL arithmetic
    (33) relational -> . arithmetic GREATER arithmetic
    (34) relational -> . arithmetic LESS arithmetic
    (35) relational -> . arithmetic GREATER_EQUAL arithmetic
    (36) relational -> . arithmetic LESS_EQUAL arithmetic
    (37) relational -> . arithmetic
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var

    READ            shift and go to state 77
    ARRAY           shift and go to state 79
    NOT             shift and go to state 59
    L_PAR           shift and go to state 56
    NOT_B           shift and go to state 62
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21
    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69

    condition                      shift and go to state 75
    conversion                     shift and go to state 76
    bitwise                        shift and go to state 78
    relational                     shift and go to state 60
    var                            shift and go to state 61
    arithmetic                     shift and go to state 66

state 41

    (56) assign -> SVAR ASSIGN . condition SEMICOLON
    (60) assign -> SVAR ASSIGN . conversion SEMICOLON
    (64) assign -> SVAR ASSIGN . READ L_PAR R_PAR SEMICOLON
    (68) assign -> SVAR ASSIGN . bitwise SEMICOLON
    (86) declaration -> SVAR ASSIGN . ARRAY L_PAR R_PAR SEMICOLON
    (27) condition -> . condition AND condition
    (28) condition -> . condition OR condition
    (29) condition -> . NOT condition
    (30) condition -> . relational
    (78) conversion -> . L_PAR type R_PAR var
    (69) bitwise -> . var AND_B var
    (70) bitwise -> . var OR_B var
    (71) bitwise -> . var XOR_B var
    (72) bitwise -> . var SHIFT_L var
    (73) bitwise -> . var SHIFT_R var
    (74) bitwise -> . NOT_B TVAR
    (75) bitwise -> . NOT_B AVAR
    (76) bitwise -> . NOT_B VVAR
    (77) bitwise -> . NOT_B SVAR
    (31) relational -> . arithmetic EQUAL arithmetic
    (32) relational -> . arithmetic NOT_EQUAL arithmetic
    (33) relational -> . arithmetic GREATER arithmetic
    (34) relational -> . arithmetic LESS arithmetic
    (35) relational -> . arithmetic GREATER_EQUAL arithmetic
    (36) relational -> . arithmetic LESS_EQUAL arithmetic
    (37) relational -> . arithmetic
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var

    READ            shift and go to state 82
    ARRAY           shift and go to state 84
    NOT             shift and go to state 59
    L_PAR           shift and go to state 56
    NOT_B           shift and go to state 62
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21
    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69

    condition                      shift and go to state 80
    conversion                     shift and go to state 81
    bitwise                        shift and go to state 83
    relational                     shift and go to state 60
    var                            shift and go to state 61
    arithmetic                     shift and go to state 66

state 42

    (18) print -> PRINT L_PAR . TVAR R_PAR SEMICOLON
    (19) print -> PRINT L_PAR . AVAR R_PAR SEMICOLON
    (20) print -> PRINT L_PAR . VVAR R_PAR SEMICOLON
    (21) print -> PRINT L_PAR . SVAR R_PAR SEMICOLON
    (22) print -> PRINT L_PAR . SPVAR R_PAR SEMICOLON
    (23) print -> PRINT L_PAR . RAVAR R_PAR SEMICOLON

    TVAR            shift and go to state 85
    AVAR            shift and go to state 86
    VVAR            shift and go to state 87
    SVAR            shift and go to state 88
    SPVAR           shift and go to state 89
    RAVAR           shift and go to state 90


state 43

    (24) exit -> EXIT SEMICOLON .

    GOTO            reduce using rule 24 (exit -> EXIT SEMICOLON .)
    UNSET           reduce using rule 24 (exit -> EXIT SEMICOLON .)
    PRINT           reduce using rule 24 (exit -> EXIT SEMICOLON .)
    EXIT            reduce using rule 24 (exit -> EXIT SEMICOLON .)
    NAME            reduce using rule 24 (exit -> EXIT SEMICOLON .)
    IF              reduce using rule 24 (exit -> EXIT SEMICOLON .)
    TVAR            reduce using rule 24 (exit -> EXIT SEMICOLON .)
    AVAR            reduce using rule 24 (exit -> EXIT SEMICOLON .)
    VVAR            reduce using rule 24 (exit -> EXIT SEMICOLON .)
    SVAR            reduce using rule 24 (exit -> EXIT SEMICOLON .)
    RAVAR           reduce using rule 24 (exit -> EXIT SEMICOLON .)
    SPVAR           reduce using rule 24 (exit -> EXIT SEMICOLON .)
    $end            reduce using rule 24 (exit -> EXIT SEMICOLON .)


state 44

    (26) if -> IF L_PAR . condition R_PAR GOTO NAME SEMICOLON
    (27) condition -> . condition AND condition
    (28) condition -> . condition OR condition
    (29) condition -> . NOT condition
    (30) condition -> . relational
    (31) relational -> . arithmetic EQUAL arithmetic
    (32) relational -> . arithmetic NOT_EQUAL arithmetic
    (33) relational -> . arithmetic GREATER arithmetic
    (34) relational -> . arithmetic LESS arithmetic
    (35) relational -> . arithmetic GREATER_EQUAL arithmetic
    (36) relational -> . arithmetic LESS_EQUAL arithmetic
    (37) relational -> . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    NOT             shift and go to state 59
    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    condition                      shift and go to state 91
    relational                     shift and go to state 60
    arithmetic                     shift and go to state 66
    var                            shift and go to state 92

state 45

    (11) goto -> GOTO NAME SEMICOLON .

    GOTO            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    UNSET           reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    PRINT           reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    EXIT            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    NAME            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    IF              reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    TVAR            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    AVAR            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    VVAR            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    SVAR            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    RAVAR           reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    SPVAR           reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)
    $end            reduce using rule 11 (goto -> GOTO NAME SEMICOLON .)


state 46

    (12) unset -> UNSET L_PAR TVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 93


state 47

    (13) unset -> UNSET L_PAR AVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 94


state 48

    (14) unset -> UNSET L_PAR VVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 95


state 49

    (15) unset -> UNSET L_PAR SVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 96


state 50

    (16) unset -> UNSET L_PAR SPVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 97


state 51

    (17) unset -> UNSET L_PAR RAVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 98


state 52

    (47) var -> TVAR .

    AND_B           reduce using rule 47 (var -> TVAR .)
    OR_B            reduce using rule 47 (var -> TVAR .)
    XOR_B           reduce using rule 47 (var -> TVAR .)
    SHIFT_L         reduce using rule 47 (var -> TVAR .)
    SHIFT_R         reduce using rule 47 (var -> TVAR .)
    EQUAL           reduce using rule 47 (var -> TVAR .)
    NOT_EQUAL       reduce using rule 47 (var -> TVAR .)
    GREATER         reduce using rule 47 (var -> TVAR .)
    LESS            reduce using rule 47 (var -> TVAR .)
    GREATER_EQUAL   reduce using rule 47 (var -> TVAR .)
    LESS_EQUAL      reduce using rule 47 (var -> TVAR .)
    PLUS            reduce using rule 47 (var -> TVAR .)
    MINUS           reduce using rule 47 (var -> TVAR .)
    MULTIPLY        reduce using rule 47 (var -> TVAR .)
    DIVIDE          reduce using rule 47 (var -> TVAR .)
    REMAINDER       reduce using rule 47 (var -> TVAR .)
    SEMICOLON       reduce using rule 47 (var -> TVAR .)
    AND             reduce using rule 47 (var -> TVAR .)
    OR              reduce using rule 47 (var -> TVAR .)
    R_PAR           reduce using rule 47 (var -> TVAR .)


state 53

    (53) assign -> TVAR ASSIGN condition . SEMICOLON
    (27) condition -> condition . AND condition
    (28) condition -> condition . OR condition

    SEMICOLON       shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101


state 54

    (57) assign -> TVAR ASSIGN conversion . SEMICOLON

    SEMICOLON       shift and go to state 102


state 55

    (61) assign -> TVAR ASSIGN READ . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 103


state 56

    (78) conversion -> L_PAR . type R_PAR var
    (79) type -> . INT
    (80) type -> . FLOAT
    (81) type -> . CHAR

    INT             shift and go to state 105
    FLOAT           shift and go to state 106
    CHAR            shift and go to state 107

    type                           shift and go to state 104

state 57

    (65) assign -> TVAR ASSIGN bitwise . SEMICOLON

    SEMICOLON       shift and go to state 108


state 58

    (83) declaration -> TVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 109


state 59

    (29) condition -> NOT . condition
    (27) condition -> . condition AND condition
    (28) condition -> . condition OR condition
    (29) condition -> . NOT condition
    (30) condition -> . relational
    (31) relational -> . arithmetic EQUAL arithmetic
    (32) relational -> . arithmetic NOT_EQUAL arithmetic
    (33) relational -> . arithmetic GREATER arithmetic
    (34) relational -> . arithmetic LESS arithmetic
    (35) relational -> . arithmetic GREATER_EQUAL arithmetic
    (36) relational -> . arithmetic LESS_EQUAL arithmetic
    (37) relational -> . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    NOT             shift and go to state 59
    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    condition                      shift and go to state 110
    relational                     shift and go to state 60
    arithmetic                     shift and go to state 66
    var                            shift and go to state 92

state 60

    (30) condition -> relational .

    SEMICOLON       reduce using rule 30 (condition -> relational .)
    AND             reduce using rule 30 (condition -> relational .)
    OR              reduce using rule 30 (condition -> relational .)
    R_PAR           reduce using rule 30 (condition -> relational .)


state 61

    (69) bitwise -> var . AND_B var
    (70) bitwise -> var . OR_B var
    (71) bitwise -> var . XOR_B var
    (72) bitwise -> var . SHIFT_L var
    (73) bitwise -> var . SHIFT_R var
    (46) arithmetic -> var .

    AND_B           shift and go to state 111
    OR_B            shift and go to state 112
    XOR_B           shift and go to state 113
    SHIFT_L         shift and go to state 114
    SHIFT_R         shift and go to state 115
    EQUAL           reduce using rule 46 (arithmetic -> var .)
    NOT_EQUAL       reduce using rule 46 (arithmetic -> var .)
    GREATER         reduce using rule 46 (arithmetic -> var .)
    LESS            reduce using rule 46 (arithmetic -> var .)
    GREATER_EQUAL   reduce using rule 46 (arithmetic -> var .)
    LESS_EQUAL      reduce using rule 46 (arithmetic -> var .)
    PLUS            reduce using rule 46 (arithmetic -> var .)
    MINUS           reduce using rule 46 (arithmetic -> var .)
    MULTIPLY        reduce using rule 46 (arithmetic -> var .)
    DIVIDE          reduce using rule 46 (arithmetic -> var .)
    REMAINDER       reduce using rule 46 (arithmetic -> var .)
    SEMICOLON       reduce using rule 46 (arithmetic -> var .)
    AND             reduce using rule 46 (arithmetic -> var .)
    OR              reduce using rule 46 (arithmetic -> var .)


state 62

    (74) bitwise -> NOT_B . TVAR
    (75) bitwise -> NOT_B . AVAR
    (76) bitwise -> NOT_B . VVAR
    (77) bitwise -> NOT_B . SVAR

    TVAR            shift and go to state 116
    AVAR            shift and go to state 117
    VVAR            shift and go to state 118
    SVAR            shift and go to state 119


state 63

    (48) var -> AVAR .

    AND_B           reduce using rule 48 (var -> AVAR .)
    OR_B            reduce using rule 48 (var -> AVAR .)
    XOR_B           reduce using rule 48 (var -> AVAR .)
    SHIFT_L         reduce using rule 48 (var -> AVAR .)
    SHIFT_R         reduce using rule 48 (var -> AVAR .)
    EQUAL           reduce using rule 48 (var -> AVAR .)
    NOT_EQUAL       reduce using rule 48 (var -> AVAR .)
    GREATER         reduce using rule 48 (var -> AVAR .)
    LESS            reduce using rule 48 (var -> AVAR .)
    GREATER_EQUAL   reduce using rule 48 (var -> AVAR .)
    LESS_EQUAL      reduce using rule 48 (var -> AVAR .)
    PLUS            reduce using rule 48 (var -> AVAR .)
    MINUS           reduce using rule 48 (var -> AVAR .)
    MULTIPLY        reduce using rule 48 (var -> AVAR .)
    DIVIDE          reduce using rule 48 (var -> AVAR .)
    REMAINDER       reduce using rule 48 (var -> AVAR .)
    SEMICOLON       reduce using rule 48 (var -> AVAR .)
    AND             reduce using rule 48 (var -> AVAR .)
    OR              reduce using rule 48 (var -> AVAR .)
    R_PAR           reduce using rule 48 (var -> AVAR .)


state 64

    (49) var -> VVAR .

    AND_B           reduce using rule 49 (var -> VVAR .)
    OR_B            reduce using rule 49 (var -> VVAR .)
    XOR_B           reduce using rule 49 (var -> VVAR .)
    SHIFT_L         reduce using rule 49 (var -> VVAR .)
    SHIFT_R         reduce using rule 49 (var -> VVAR .)
    EQUAL           reduce using rule 49 (var -> VVAR .)
    NOT_EQUAL       reduce using rule 49 (var -> VVAR .)
    GREATER         reduce using rule 49 (var -> VVAR .)
    LESS            reduce using rule 49 (var -> VVAR .)
    GREATER_EQUAL   reduce using rule 49 (var -> VVAR .)
    LESS_EQUAL      reduce using rule 49 (var -> VVAR .)
    PLUS            reduce using rule 49 (var -> VVAR .)
    MINUS           reduce using rule 49 (var -> VVAR .)
    MULTIPLY        reduce using rule 49 (var -> VVAR .)
    DIVIDE          reduce using rule 49 (var -> VVAR .)
    REMAINDER       reduce using rule 49 (var -> VVAR .)
    SEMICOLON       reduce using rule 49 (var -> VVAR .)
    AND             reduce using rule 49 (var -> VVAR .)
    OR              reduce using rule 49 (var -> VVAR .)
    R_PAR           reduce using rule 49 (var -> VVAR .)


state 65

    (50) var -> SVAR .

    AND_B           reduce using rule 50 (var -> SVAR .)
    OR_B            reduce using rule 50 (var -> SVAR .)
    XOR_B           reduce using rule 50 (var -> SVAR .)
    SHIFT_L         reduce using rule 50 (var -> SVAR .)
    SHIFT_R         reduce using rule 50 (var -> SVAR .)
    EQUAL           reduce using rule 50 (var -> SVAR .)
    NOT_EQUAL       reduce using rule 50 (var -> SVAR .)
    GREATER         reduce using rule 50 (var -> SVAR .)
    LESS            reduce using rule 50 (var -> SVAR .)
    GREATER_EQUAL   reduce using rule 50 (var -> SVAR .)
    LESS_EQUAL      reduce using rule 50 (var -> SVAR .)
    PLUS            reduce using rule 50 (var -> SVAR .)
    MINUS           reduce using rule 50 (var -> SVAR .)
    MULTIPLY        reduce using rule 50 (var -> SVAR .)
    DIVIDE          reduce using rule 50 (var -> SVAR .)
    REMAINDER       reduce using rule 50 (var -> SVAR .)
    SEMICOLON       reduce using rule 50 (var -> SVAR .)
    AND             reduce using rule 50 (var -> SVAR .)
    OR              reduce using rule 50 (var -> SVAR .)
    R_PAR           reduce using rule 50 (var -> SVAR .)


state 66

    (31) relational -> arithmetic . EQUAL arithmetic
    (32) relational -> arithmetic . NOT_EQUAL arithmetic
    (33) relational -> arithmetic . GREATER arithmetic
    (34) relational -> arithmetic . LESS arithmetic
    (35) relational -> arithmetic . GREATER_EQUAL arithmetic
    (36) relational -> arithmetic . LESS_EQUAL arithmetic
    (37) relational -> arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           shift and go to state 120
    NOT_EQUAL       shift and go to state 121
    GREATER         shift and go to state 122
    LESS            shift and go to state 123
    GREATER_EQUAL   shift and go to state 124
    LESS_EQUAL      shift and go to state 125
    SEMICOLON       reduce using rule 37 (relational -> arithmetic .)
    AND             reduce using rule 37 (relational -> arithmetic .)
    OR              reduce using rule 37 (relational -> arithmetic .)
    R_PAR           reduce using rule 37 (relational -> arithmetic .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129
    REMAINDER       shift and go to state 130


state 67

    (43) arithmetic -> INTEGER .

    EQUAL           reduce using rule 43 (arithmetic -> INTEGER .)
    NOT_EQUAL       reduce using rule 43 (arithmetic -> INTEGER .)
    GREATER         reduce using rule 43 (arithmetic -> INTEGER .)
    LESS            reduce using rule 43 (arithmetic -> INTEGER .)
    GREATER_EQUAL   reduce using rule 43 (arithmetic -> INTEGER .)
    LESS_EQUAL      reduce using rule 43 (arithmetic -> INTEGER .)
    PLUS            reduce using rule 43 (arithmetic -> INTEGER .)
    MINUS           reduce using rule 43 (arithmetic -> INTEGER .)
    MULTIPLY        reduce using rule 43 (arithmetic -> INTEGER .)
    DIVIDE          reduce using rule 43 (arithmetic -> INTEGER .)
    REMAINDER       reduce using rule 43 (arithmetic -> INTEGER .)
    SEMICOLON       reduce using rule 43 (arithmetic -> INTEGER .)
    AND             reduce using rule 43 (arithmetic -> INTEGER .)
    OR              reduce using rule 43 (arithmetic -> INTEGER .)
    R_PAR           reduce using rule 43 (arithmetic -> INTEGER .)


state 68

    (44) arithmetic -> DECIMAL .

    EQUAL           reduce using rule 44 (arithmetic -> DECIMAL .)
    NOT_EQUAL       reduce using rule 44 (arithmetic -> DECIMAL .)
    GREATER         reduce using rule 44 (arithmetic -> DECIMAL .)
    LESS            reduce using rule 44 (arithmetic -> DECIMAL .)
    GREATER_EQUAL   reduce using rule 44 (arithmetic -> DECIMAL .)
    LESS_EQUAL      reduce using rule 44 (arithmetic -> DECIMAL .)
    PLUS            reduce using rule 44 (arithmetic -> DECIMAL .)
    MINUS           reduce using rule 44 (arithmetic -> DECIMAL .)
    MULTIPLY        reduce using rule 44 (arithmetic -> DECIMAL .)
    DIVIDE          reduce using rule 44 (arithmetic -> DECIMAL .)
    REMAINDER       reduce using rule 44 (arithmetic -> DECIMAL .)
    SEMICOLON       reduce using rule 44 (arithmetic -> DECIMAL .)
    AND             reduce using rule 44 (arithmetic -> DECIMAL .)
    OR              reduce using rule 44 (arithmetic -> DECIMAL .)
    R_PAR           reduce using rule 44 (arithmetic -> DECIMAL .)


state 69

    (45) arithmetic -> STRING .

    EQUAL           reduce using rule 45 (arithmetic -> STRING .)
    NOT_EQUAL       reduce using rule 45 (arithmetic -> STRING .)
    GREATER         reduce using rule 45 (arithmetic -> STRING .)
    LESS            reduce using rule 45 (arithmetic -> STRING .)
    GREATER_EQUAL   reduce using rule 45 (arithmetic -> STRING .)
    LESS_EQUAL      reduce using rule 45 (arithmetic -> STRING .)
    PLUS            reduce using rule 45 (arithmetic -> STRING .)
    MINUS           reduce using rule 45 (arithmetic -> STRING .)
    MULTIPLY        reduce using rule 45 (arithmetic -> STRING .)
    DIVIDE          reduce using rule 45 (arithmetic -> STRING .)
    REMAINDER       reduce using rule 45 (arithmetic -> STRING .)
    SEMICOLON       reduce using rule 45 (arithmetic -> STRING .)
    AND             reduce using rule 45 (arithmetic -> STRING .)
    OR              reduce using rule 45 (arithmetic -> STRING .)
    R_PAR           reduce using rule 45 (arithmetic -> STRING .)


state 70

    (54) assign -> AVAR ASSIGN condition . SEMICOLON
    (27) condition -> condition . AND condition
    (28) condition -> condition . OR condition

    SEMICOLON       shift and go to state 131
    AND             shift and go to state 100
    OR              shift and go to state 101


state 71

    (58) assign -> AVAR ASSIGN conversion . SEMICOLON

    SEMICOLON       shift and go to state 132


state 72

    (62) assign -> AVAR ASSIGN READ . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 133


state 73

    (66) assign -> AVAR ASSIGN bitwise . SEMICOLON

    SEMICOLON       shift and go to state 134


state 74

    (84) declaration -> AVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 135


state 75

    (55) assign -> VVAR ASSIGN condition . SEMICOLON
    (27) condition -> condition . AND condition
    (28) condition -> condition . OR condition

    SEMICOLON       shift and go to state 136
    AND             shift and go to state 100
    OR              shift and go to state 101


state 76

    (59) assign -> VVAR ASSIGN conversion . SEMICOLON

    SEMICOLON       shift and go to state 137


state 77

    (63) assign -> VVAR ASSIGN READ . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 138


state 78

    (67) assign -> VVAR ASSIGN bitwise . SEMICOLON

    SEMICOLON       shift and go to state 139


state 79

    (85) declaration -> VVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 140


state 80

    (56) assign -> SVAR ASSIGN condition . SEMICOLON
    (27) condition -> condition . AND condition
    (28) condition -> condition . OR condition

    SEMICOLON       shift and go to state 141
    AND             shift and go to state 100
    OR              shift and go to state 101


state 81

    (60) assign -> SVAR ASSIGN conversion . SEMICOLON

    SEMICOLON       shift and go to state 142


state 82

    (64) assign -> SVAR ASSIGN READ . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 143


state 83

    (68) assign -> SVAR ASSIGN bitwise . SEMICOLON

    SEMICOLON       shift and go to state 144


state 84

    (86) declaration -> SVAR ASSIGN ARRAY . L_PAR R_PAR SEMICOLON

    L_PAR           shift and go to state 145


state 85

    (18) print -> PRINT L_PAR TVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 146


state 86

    (19) print -> PRINT L_PAR AVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 147


state 87

    (20) print -> PRINT L_PAR VVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 148


state 88

    (21) print -> PRINT L_PAR SVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 149


state 89

    (22) print -> PRINT L_PAR SPVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 150


state 90

    (23) print -> PRINT L_PAR RAVAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 151


state 91

    (26) if -> IF L_PAR condition . R_PAR GOTO NAME SEMICOLON
    (27) condition -> condition . AND condition
    (28) condition -> condition . OR condition

    R_PAR           shift and go to state 152
    AND             shift and go to state 100
    OR              shift and go to state 101


state 92

    (46) arithmetic -> var .

    EQUAL           reduce using rule 46 (arithmetic -> var .)
    NOT_EQUAL       reduce using rule 46 (arithmetic -> var .)
    GREATER         reduce using rule 46 (arithmetic -> var .)
    LESS            reduce using rule 46 (arithmetic -> var .)
    GREATER_EQUAL   reduce using rule 46 (arithmetic -> var .)
    LESS_EQUAL      reduce using rule 46 (arithmetic -> var .)
    PLUS            reduce using rule 46 (arithmetic -> var .)
    MINUS           reduce using rule 46 (arithmetic -> var .)
    MULTIPLY        reduce using rule 46 (arithmetic -> var .)
    DIVIDE          reduce using rule 46 (arithmetic -> var .)
    REMAINDER       reduce using rule 46 (arithmetic -> var .)
    R_PAR           reduce using rule 46 (arithmetic -> var .)
    AND             reduce using rule 46 (arithmetic -> var .)
    OR              reduce using rule 46 (arithmetic -> var .)
    SEMICOLON       reduce using rule 46 (arithmetic -> var .)


state 93

    (12) unset -> UNSET L_PAR TVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 153


state 94

    (13) unset -> UNSET L_PAR AVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 154


state 95

    (14) unset -> UNSET L_PAR VVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 155


state 96

    (15) unset -> UNSET L_PAR SVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 156


state 97

    (16) unset -> UNSET L_PAR SPVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 157


state 98

    (17) unset -> UNSET L_PAR RAVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 158


state 99

    (53) assign -> TVAR ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    IF              reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)
    $end            reduce using rule 53 (assign -> TVAR ASSIGN condition SEMICOLON .)


state 100

    (27) condition -> condition AND . condition
    (27) condition -> . condition AND condition
    (28) condition -> . condition OR condition
    (29) condition -> . NOT condition
    (30) condition -> . relational
    (31) relational -> . arithmetic EQUAL arithmetic
    (32) relational -> . arithmetic NOT_EQUAL arithmetic
    (33) relational -> . arithmetic GREATER arithmetic
    (34) relational -> . arithmetic LESS arithmetic
    (35) relational -> . arithmetic GREATER_EQUAL arithmetic
    (36) relational -> . arithmetic LESS_EQUAL arithmetic
    (37) relational -> . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    NOT             shift and go to state 59
    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    condition                      shift and go to state 159
    relational                     shift and go to state 60
    arithmetic                     shift and go to state 66
    var                            shift and go to state 92

state 101

    (28) condition -> condition OR . condition
    (27) condition -> . condition AND condition
    (28) condition -> . condition OR condition
    (29) condition -> . NOT condition
    (30) condition -> . relational
    (31) relational -> . arithmetic EQUAL arithmetic
    (32) relational -> . arithmetic NOT_EQUAL arithmetic
    (33) relational -> . arithmetic GREATER arithmetic
    (34) relational -> . arithmetic LESS arithmetic
    (35) relational -> . arithmetic GREATER_EQUAL arithmetic
    (36) relational -> . arithmetic LESS_EQUAL arithmetic
    (37) relational -> . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    NOT             shift and go to state 59
    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    condition                      shift and go to state 160
    relational                     shift and go to state 60
    arithmetic                     shift and go to state 66
    var                            shift and go to state 92

state 102

    (57) assign -> TVAR ASSIGN conversion SEMICOLON .

    GOTO            reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    UNSET           reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    PRINT           reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    EXIT            reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    NAME            reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    IF              reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    TVAR            reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    AVAR            reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    VVAR            reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    SVAR            reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    RAVAR           reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    SPVAR           reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)
    $end            reduce using rule 57 (assign -> TVAR ASSIGN conversion SEMICOLON .)


state 103

    (61) assign -> TVAR ASSIGN READ L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 161


state 104

    (78) conversion -> L_PAR type . R_PAR var

    R_PAR           shift and go to state 162


state 105

    (79) type -> INT .

    R_PAR           reduce using rule 79 (type -> INT .)


state 106

    (80) type -> FLOAT .

    R_PAR           reduce using rule 80 (type -> FLOAT .)


state 107

    (81) type -> CHAR .

    R_PAR           reduce using rule 81 (type -> CHAR .)


state 108

    (65) assign -> TVAR ASSIGN bitwise SEMICOLON .

    GOTO            reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    UNSET           reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    PRINT           reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    EXIT            reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    NAME            reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    IF              reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    TVAR            reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    AVAR            reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    VVAR            reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    SVAR            reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    RAVAR           reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    SPVAR           reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)
    $end            reduce using rule 65 (assign -> TVAR ASSIGN bitwise SEMICOLON .)


state 109

    (83) declaration -> TVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 163


state 110

    (29) condition -> NOT condition .
    (27) condition -> condition . AND condition
    (28) condition -> condition . OR condition

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 29 (condition -> NOT condition .)
    R_PAR           reduce using rule 29 (condition -> NOT condition .)
    AND             shift and go to state 100
    OR              shift and go to state 101

  ! AND             [ reduce using rule 29 (condition -> NOT condition .) ]
  ! OR              [ reduce using rule 29 (condition -> NOT condition .) ]


state 111

    (69) bitwise -> var AND_B . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    var                            shift and go to state 164

state 112

    (70) bitwise -> var OR_B . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    var                            shift and go to state 165

state 113

    (71) bitwise -> var XOR_B . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    var                            shift and go to state 166

state 114

    (72) bitwise -> var SHIFT_L . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    var                            shift and go to state 167

state 115

    (73) bitwise -> var SHIFT_R . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    var                            shift and go to state 168

state 116

    (74) bitwise -> NOT_B TVAR .

    SEMICOLON       reduce using rule 74 (bitwise -> NOT_B TVAR .)


state 117

    (75) bitwise -> NOT_B AVAR .

    SEMICOLON       reduce using rule 75 (bitwise -> NOT_B AVAR .)


state 118

    (76) bitwise -> NOT_B VVAR .

    SEMICOLON       reduce using rule 76 (bitwise -> NOT_B VVAR .)


state 119

    (77) bitwise -> NOT_B SVAR .

    SEMICOLON       reduce using rule 77 (bitwise -> NOT_B SVAR .)


state 120

    (31) relational -> arithmetic EQUAL . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 169
    var                            shift and go to state 92

state 121

    (32) relational -> arithmetic NOT_EQUAL . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 170
    var                            shift and go to state 92

state 122

    (33) relational -> arithmetic GREATER . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 171
    var                            shift and go to state 92

state 123

    (34) relational -> arithmetic LESS . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 172
    var                            shift and go to state 92

state 124

    (35) relational -> arithmetic GREATER_EQUAL . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 173
    var                            shift and go to state 92

state 125

    (36) relational -> arithmetic LESS_EQUAL . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 174
    var                            shift and go to state 92

state 126

    (38) arithmetic -> arithmetic PLUS . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 175
    var                            shift and go to state 92

state 127

    (39) arithmetic -> arithmetic MINUS . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 176
    var                            shift and go to state 92

state 128

    (40) arithmetic -> arithmetic MULTIPLY . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 177
    var                            shift and go to state 92

state 129

    (41) arithmetic -> arithmetic DIVIDE . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 178
    var                            shift and go to state 92

state 130

    (42) arithmetic -> arithmetic REMAINDER . arithmetic
    (38) arithmetic -> . arithmetic PLUS arithmetic
    (39) arithmetic -> . arithmetic MINUS arithmetic
    (40) arithmetic -> . arithmetic MULTIPLY arithmetic
    (41) arithmetic -> . arithmetic DIVIDE arithmetic
    (42) arithmetic -> . arithmetic REMAINDER arithmetic
    (43) arithmetic -> . INTEGER
    (44) arithmetic -> . DECIMAL
    (45) arithmetic -> . STRING
    (46) arithmetic -> . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    INTEGER         shift and go to state 67
    DECIMAL         shift and go to state 68
    STRING          shift and go to state 69
    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    arithmetic                     shift and go to state 179
    var                            shift and go to state 92

state 131

    (54) assign -> AVAR ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    IF              reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)
    $end            reduce using rule 54 (assign -> AVAR ASSIGN condition SEMICOLON .)


state 132

    (58) assign -> AVAR ASSIGN conversion SEMICOLON .

    GOTO            reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    UNSET           reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    PRINT           reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    EXIT            reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    NAME            reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    IF              reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    TVAR            reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    AVAR            reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    VVAR            reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    SVAR            reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    RAVAR           reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    SPVAR           reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)
    $end            reduce using rule 58 (assign -> AVAR ASSIGN conversion SEMICOLON .)


state 133

    (62) assign -> AVAR ASSIGN READ L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 180


state 134

    (66) assign -> AVAR ASSIGN bitwise SEMICOLON .

    GOTO            reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    UNSET           reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    PRINT           reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    EXIT            reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    NAME            reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    IF              reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    TVAR            reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    AVAR            reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    VVAR            reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    SVAR            reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    RAVAR           reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    SPVAR           reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)
    $end            reduce using rule 66 (assign -> AVAR ASSIGN bitwise SEMICOLON .)


state 135

    (84) declaration -> AVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 181


state 136

    (55) assign -> VVAR ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    IF              reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)
    $end            reduce using rule 55 (assign -> VVAR ASSIGN condition SEMICOLON .)


state 137

    (59) assign -> VVAR ASSIGN conversion SEMICOLON .

    GOTO            reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    UNSET           reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    PRINT           reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    EXIT            reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    NAME            reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    IF              reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    TVAR            reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    AVAR            reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    VVAR            reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    SVAR            reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    RAVAR           reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    SPVAR           reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)
    $end            reduce using rule 59 (assign -> VVAR ASSIGN conversion SEMICOLON .)


state 138

    (63) assign -> VVAR ASSIGN READ L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 182


state 139

    (67) assign -> VVAR ASSIGN bitwise SEMICOLON .

    GOTO            reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    UNSET           reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    PRINT           reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    EXIT            reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    NAME            reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    IF              reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    TVAR            reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    AVAR            reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    VVAR            reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    SVAR            reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    RAVAR           reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    SPVAR           reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)
    $end            reduce using rule 67 (assign -> VVAR ASSIGN bitwise SEMICOLON .)


state 140

    (85) declaration -> VVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 183


state 141

    (56) assign -> SVAR ASSIGN condition SEMICOLON .

    GOTO            reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    UNSET           reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    PRINT           reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    EXIT            reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    NAME            reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    IF              reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    TVAR            reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    AVAR            reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    VVAR            reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    SVAR            reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    RAVAR           reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    SPVAR           reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)
    $end            reduce using rule 56 (assign -> SVAR ASSIGN condition SEMICOLON .)


state 142

    (60) assign -> SVAR ASSIGN conversion SEMICOLON .

    GOTO            reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    UNSET           reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    PRINT           reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    EXIT            reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    NAME            reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    IF              reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    TVAR            reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    AVAR            reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    VVAR            reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    SVAR            reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    RAVAR           reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    SPVAR           reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)
    $end            reduce using rule 60 (assign -> SVAR ASSIGN conversion SEMICOLON .)


state 143

    (64) assign -> SVAR ASSIGN READ L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 184


state 144

    (68) assign -> SVAR ASSIGN bitwise SEMICOLON .

    GOTO            reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    UNSET           reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    PRINT           reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    EXIT            reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    NAME            reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    IF              reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    TVAR            reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    AVAR            reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    VVAR            reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    SVAR            reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    RAVAR           reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    SPVAR           reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)
    $end            reduce using rule 68 (assign -> SVAR ASSIGN bitwise SEMICOLON .)


state 145

    (86) declaration -> SVAR ASSIGN ARRAY L_PAR . R_PAR SEMICOLON

    R_PAR           shift and go to state 185


state 146

    (18) print -> PRINT L_PAR TVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 186


state 147

    (19) print -> PRINT L_PAR AVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 187


state 148

    (20) print -> PRINT L_PAR VVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 188


state 149

    (21) print -> PRINT L_PAR SVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 189


state 150

    (22) print -> PRINT L_PAR SPVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 190


state 151

    (23) print -> PRINT L_PAR RAVAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 191


state 152

    (26) if -> IF L_PAR condition R_PAR . GOTO NAME SEMICOLON

    GOTO            shift and go to state 192


state 153

    (12) unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    IF              reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)
    $end            reduce using rule 12 (unset -> UNSET L_PAR TVAR R_PAR SEMICOLON .)


state 154

    (13) unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    IF              reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)
    $end            reduce using rule 13 (unset -> UNSET L_PAR AVAR R_PAR SEMICOLON .)


state 155

    (14) unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    IF              reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)
    $end            reduce using rule 14 (unset -> UNSET L_PAR VVAR R_PAR SEMICOLON .)


state 156

    (15) unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    IF              reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)
    $end            reduce using rule 15 (unset -> UNSET L_PAR SVAR R_PAR SEMICOLON .)


state 157

    (16) unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    IF              reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)
    $end            reduce using rule 16 (unset -> UNSET L_PAR SPVAR R_PAR SEMICOLON .)


state 158

    (17) unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    IF              reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)
    $end            reduce using rule 17 (unset -> UNSET L_PAR RAVAR R_PAR SEMICOLON .)


state 159

    (27) condition -> condition AND condition .
    (27) condition -> condition . AND condition
    (28) condition -> condition . OR condition

    SEMICOLON       reduce using rule 27 (condition -> condition AND condition .)
    AND             reduce using rule 27 (condition -> condition AND condition .)
    OR              reduce using rule 27 (condition -> condition AND condition .)
    R_PAR           reduce using rule 27 (condition -> condition AND condition .)

  ! AND             [ shift and go to state 100 ]
  ! OR              [ shift and go to state 101 ]


state 160

    (28) condition -> condition OR condition .
    (27) condition -> condition . AND condition
    (28) condition -> condition . OR condition

    SEMICOLON       reduce using rule 28 (condition -> condition OR condition .)
    OR              reduce using rule 28 (condition -> condition OR condition .)
    R_PAR           reduce using rule 28 (condition -> condition OR condition .)
    AND             shift and go to state 100

  ! AND             [ reduce using rule 28 (condition -> condition OR condition .) ]
  ! OR              [ shift and go to state 101 ]


state 161

    (61) assign -> TVAR ASSIGN READ L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 193


state 162

    (78) conversion -> L_PAR type R_PAR . var
    (47) var -> . TVAR
    (48) var -> . AVAR
    (49) var -> . VVAR
    (50) var -> . SVAR
    (51) var -> . RAVAR
    (52) var -> . SPVAR

    TVAR            shift and go to state 52
    AVAR            shift and go to state 63
    VVAR            shift and go to state 64
    SVAR            shift and go to state 65
    RAVAR           shift and go to state 22
    SPVAR           shift and go to state 21

    var                            shift and go to state 194

state 163

    (83) declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 195


state 164

    (69) bitwise -> var AND_B var .

    SEMICOLON       reduce using rule 69 (bitwise -> var AND_B var .)


state 165

    (70) bitwise -> var OR_B var .

    SEMICOLON       reduce using rule 70 (bitwise -> var OR_B var .)


state 166

    (71) bitwise -> var XOR_B var .

    SEMICOLON       reduce using rule 71 (bitwise -> var XOR_B var .)


state 167

    (72) bitwise -> var SHIFT_L var .

    SEMICOLON       reduce using rule 72 (bitwise -> var SHIFT_L var .)


state 168

    (73) bitwise -> var SHIFT_R var .

    SEMICOLON       reduce using rule 73 (bitwise -> var SHIFT_R var .)


state 169

    (31) relational -> arithmetic EQUAL arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 31 (relational -> arithmetic EQUAL arithmetic .)
    AND             reduce using rule 31 (relational -> arithmetic EQUAL arithmetic .)
    OR              reduce using rule 31 (relational -> arithmetic EQUAL arithmetic .)
    R_PAR           reduce using rule 31 (relational -> arithmetic EQUAL arithmetic .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129
    REMAINDER       shift and go to state 130


state 170

    (32) relational -> arithmetic NOT_EQUAL arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 32 (relational -> arithmetic NOT_EQUAL arithmetic .)
    AND             reduce using rule 32 (relational -> arithmetic NOT_EQUAL arithmetic .)
    OR              reduce using rule 32 (relational -> arithmetic NOT_EQUAL arithmetic .)
    R_PAR           reduce using rule 32 (relational -> arithmetic NOT_EQUAL arithmetic .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129
    REMAINDER       shift and go to state 130


state 171

    (33) relational -> arithmetic GREATER arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 33 (relational -> arithmetic GREATER arithmetic .)
    AND             reduce using rule 33 (relational -> arithmetic GREATER arithmetic .)
    OR              reduce using rule 33 (relational -> arithmetic GREATER arithmetic .)
    R_PAR           reduce using rule 33 (relational -> arithmetic GREATER arithmetic .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129
    REMAINDER       shift and go to state 130


state 172

    (34) relational -> arithmetic LESS arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 34 (relational -> arithmetic LESS arithmetic .)
    AND             reduce using rule 34 (relational -> arithmetic LESS arithmetic .)
    OR              reduce using rule 34 (relational -> arithmetic LESS arithmetic .)
    R_PAR           reduce using rule 34 (relational -> arithmetic LESS arithmetic .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129
    REMAINDER       shift and go to state 130


state 173

    (35) relational -> arithmetic GREATER_EQUAL arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 35 (relational -> arithmetic GREATER_EQUAL arithmetic .)
    AND             reduce using rule 35 (relational -> arithmetic GREATER_EQUAL arithmetic .)
    OR              reduce using rule 35 (relational -> arithmetic GREATER_EQUAL arithmetic .)
    R_PAR           reduce using rule 35 (relational -> arithmetic GREATER_EQUAL arithmetic .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129
    REMAINDER       shift and go to state 130


state 174

    (36) relational -> arithmetic LESS_EQUAL arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    SEMICOLON       reduce using rule 36 (relational -> arithmetic LESS_EQUAL arithmetic .)
    AND             reduce using rule 36 (relational -> arithmetic LESS_EQUAL arithmetic .)
    OR              reduce using rule 36 (relational -> arithmetic LESS_EQUAL arithmetic .)
    R_PAR           reduce using rule 36 (relational -> arithmetic LESS_EQUAL arithmetic .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129
    REMAINDER       shift and go to state 130


state 175

    (38) arithmetic -> arithmetic PLUS arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    NOT_EQUAL       reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    GREATER         reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    LESS            reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    GREATER_EQUAL   reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    LESS_EQUAL      reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    PLUS            reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    MINUS           reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    REMAINDER       reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    SEMICOLON       reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    AND             reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    OR              reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    R_PAR           reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .)
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129

  ! MULTIPLY        [ reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .) ]
  ! DIVIDE          [ reduce using rule 38 (arithmetic -> arithmetic PLUS arithmetic .) ]
  ! PLUS            [ shift and go to state 126 ]
  ! MINUS           [ shift and go to state 127 ]
  ! REMAINDER       [ shift and go to state 130 ]


state 176

    (39) arithmetic -> arithmetic MINUS arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    NOT_EQUAL       reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    GREATER         reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    LESS            reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    GREATER_EQUAL   reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    LESS_EQUAL      reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    PLUS            reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    MINUS           reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    REMAINDER       reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    SEMICOLON       reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    AND             reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    OR              reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    R_PAR           reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .)
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129

  ! MULTIPLY        [ reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .) ]
  ! DIVIDE          [ reduce using rule 39 (arithmetic -> arithmetic MINUS arithmetic .) ]
  ! PLUS            [ shift and go to state 126 ]
  ! MINUS           [ shift and go to state 127 ]
  ! REMAINDER       [ shift and go to state 130 ]


state 177

    (40) arithmetic -> arithmetic MULTIPLY arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    NOT_EQUAL       reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    GREATER         reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    LESS            reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    GREATER_EQUAL   reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    LESS_EQUAL      reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    PLUS            reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    MINUS           reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    MULTIPLY        reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    DIVIDE          reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    REMAINDER       reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    SEMICOLON       reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    AND             reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    OR              reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)
    R_PAR           reduce using rule 40 (arithmetic -> arithmetic MULTIPLY arithmetic .)

  ! PLUS            [ shift and go to state 126 ]
  ! MINUS           [ shift and go to state 127 ]
  ! MULTIPLY        [ shift and go to state 128 ]
  ! DIVIDE          [ shift and go to state 129 ]
  ! REMAINDER       [ shift and go to state 130 ]


state 178

    (41) arithmetic -> arithmetic DIVIDE arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

    EQUAL           reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    NOT_EQUAL       reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    GREATER         reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    LESS            reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    GREATER_EQUAL   reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    LESS_EQUAL      reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    PLUS            reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    MINUS           reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    MULTIPLY        reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    DIVIDE          reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    REMAINDER       reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    SEMICOLON       reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    AND             reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    OR              reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)
    R_PAR           reduce using rule 41 (arithmetic -> arithmetic DIVIDE arithmetic .)

  ! PLUS            [ shift and go to state 126 ]
  ! MINUS           [ shift and go to state 127 ]
  ! MULTIPLY        [ shift and go to state 128 ]
  ! DIVIDE          [ shift and go to state 129 ]
  ! REMAINDER       [ shift and go to state 130 ]


state 179

    (42) arithmetic -> arithmetic REMAINDER arithmetic .
    (38) arithmetic -> arithmetic . PLUS arithmetic
    (39) arithmetic -> arithmetic . MINUS arithmetic
    (40) arithmetic -> arithmetic . MULTIPLY arithmetic
    (41) arithmetic -> arithmetic . DIVIDE arithmetic
    (42) arithmetic -> arithmetic . REMAINDER arithmetic

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for REMAINDER resolved as shift
    EQUAL           reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    NOT_EQUAL       reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    GREATER         reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    LESS            reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    GREATER_EQUAL   reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    LESS_EQUAL      reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    SEMICOLON       reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    AND             reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    OR              reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    R_PAR           reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .)
    PLUS            shift and go to state 126
    MINUS           shift and go to state 127
    MULTIPLY        shift and go to state 128
    DIVIDE          shift and go to state 129
    REMAINDER       shift and go to state 130

  ! PLUS            [ reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .) ]
  ! MINUS           [ reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .) ]
  ! MULTIPLY        [ reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .) ]
  ! DIVIDE          [ reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .) ]
  ! REMAINDER       [ reduce using rule 42 (arithmetic -> arithmetic REMAINDER arithmetic .) ]


state 180

    (62) assign -> AVAR ASSIGN READ L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 196


state 181

    (84) declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 197


state 182

    (63) assign -> VVAR ASSIGN READ L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 198


state 183

    (85) declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 199


state 184

    (64) assign -> SVAR ASSIGN READ L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 200


state 185

    (86) declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR . SEMICOLON

    SEMICOLON       shift and go to state 201


state 186

    (18) print -> PRINT L_PAR TVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    IF              reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)
    $end            reduce using rule 18 (print -> PRINT L_PAR TVAR R_PAR SEMICOLON .)


state 187

    (19) print -> PRINT L_PAR AVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    IF              reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)
    $end            reduce using rule 19 (print -> PRINT L_PAR AVAR R_PAR SEMICOLON .)


state 188

    (20) print -> PRINT L_PAR VVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    IF              reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)
    $end            reduce using rule 20 (print -> PRINT L_PAR VVAR R_PAR SEMICOLON .)


state 189

    (21) print -> PRINT L_PAR SVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    IF              reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)
    $end            reduce using rule 21 (print -> PRINT L_PAR SVAR R_PAR SEMICOLON .)


state 190

    (22) print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    IF              reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)
    $end            reduce using rule 22 (print -> PRINT L_PAR SPVAR R_PAR SEMICOLON .)


state 191

    (23) print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .

    GOTO            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    NAME            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    IF              reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)
    $end            reduce using rule 23 (print -> PRINT L_PAR RAVAR R_PAR SEMICOLON .)


state 192

    (26) if -> IF L_PAR condition R_PAR GOTO . NAME SEMICOLON

    NAME            shift and go to state 202


state 193

    (61) assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 61 (assign -> TVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)


state 194

    (78) conversion -> L_PAR type R_PAR var .

    SEMICOLON       reduce using rule 78 (conversion -> L_PAR type R_PAR var .)


state 195

    (83) declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 83 (declaration -> TVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 196

    (62) assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 62 (assign -> AVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)


state 197

    (84) declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 84 (declaration -> AVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 198

    (63) assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 63 (assign -> VVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)


state 199

    (85) declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 85 (declaration -> VVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 200

    (64) assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 64 (assign -> SVAR ASSIGN READ L_PAR R_PAR SEMICOLON .)


state 201

    (86) declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .

    GOTO            reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    UNSET           reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    PRINT           reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    EXIT            reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    NAME            reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    IF              reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    TVAR            reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    AVAR            reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    VVAR            reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SVAR            reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    RAVAR           reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    SPVAR           reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)
    $end            reduce using rule 86 (declaration -> SVAR ASSIGN ARRAY L_PAR R_PAR SEMICOLON .)


state 202

    (26) if -> IF L_PAR condition R_PAR GOTO NAME . SEMICOLON

    SEMICOLON       shift and go to state 203


state 203

    (26) if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .

    GOTO            reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    UNSET           reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    PRINT           reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    EXIT            reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    NAME            reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    IF              reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    TVAR            reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    AVAR            reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    VVAR            reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    SVAR            reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    RAVAR           reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    SPVAR           reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)
    $end            reduce using rule 26 (if -> IF L_PAR condition R_PAR GOTO NAME SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 110 resolved as shift
WARNING: shift/reduce conflict for OR in state 110 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 179 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 179 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 179 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 179 resolved as shift
WARNING: shift/reduce conflict for REMAINDER in state 179 resolved as shift
